import requests
import json
import time
from helper_funcs import *
from db_ops import *
from prometheus_client.core import CollectorRegistry, GaugeMetricFamily, REGISTRY, CounterMetricFamily, Gauge
from prometheus_client import start_http_server
from os.path import isfile, dirname
import re

def increment_metric_state(gauge_name, key):
    """
    Increments a metric in data_obj by 1

    Parameters:
    -----------
    gauge_name : str
        The name of the metric to increment
    key : str / hex
        The public key of the associated validator
    """
    global data_obj

    # first checks if entry exists
    if key not in data_obj["latest_metrics"][gauge_name]:
        data_obj["latest_metrics"][gauge_name][key] = 0

    data_obj["latest_metrics"][gauge_name][key] += 1

def init_metric_state(gauge_name, key):
    """
    Initliases a metric in data_obj by setting it to 0

    Parameters:
    -----------
    gauge_name : str
        The name of the metric to initialise
    key : str / hex
        The public key of the associated validator
    """
    global data_obj

    data_obj["latest_metrics"][gauge_name][key] = 0

def increment_blocks_proposed(public_key, relay):
    """
    Increments respective metrics when a validator proposes a new block

    Parameters:
    -----------
    public_key : str / hex
        The public key of the validator that proposed the block
    relay : str
        The name of the relay through which the block was relayed
    """
    global relay_blocks_gauge, validator_totals_gauge

    relay_blocks_gauge.labels(relay).inc()
    increment_metric_state("RelayBlocksProposed", relay)
    validator_totals_gauge.labels(public_key).inc() 
    increment_metric_state("ValidatorBlocksProposed", public_key)

def update_validator_reward_metrics(relayer, reward):
    """
    Updates metrics related to rewards incurred by validators we are monitoring

    Parameters:
    -----------
    relay : str
        The name of the relay through which the block was relayed, or 'Unknown' otherwise
    reward : float
        The reward incurred by proposing the block
    """
    global val_total_rewards_gauge, val_avg_reward_gauge, val_unknown_reward_blocks, data_obj

    # if the reward is unknown
    if reward == -1:
        # update the number of blocks with unknown rewards
        val_unknown_reward_blocks.labels(relayer).inc()
        update_relayer_metric_state("ValUnknownRewardBlocks", relayer, 1)
    else:
        # update the total rewards generated by our validators by using this relayer
        val_total_rewards_gauge.labels(relayer).inc(reward)
        update_relayer_metric_state("TotalValidatorRewards", relayer, reward)

        # check if calculation results in 0 first
        if (data_obj["latest_metrics"]["RelayBlocksProposed"][relayer] - data_obj["latest_metrics"]["ValUnknownRewardBlocks"][relayer]) != 0:
            # update average reward of our validators using this specific relayer
            avg = data_obj["latest_metrics"]["TotalValidatorRewards"][relayer] / (data_obj["latest_metrics"]["RelayBlocksProposed"][relayer] - data_obj["latest_metrics"]["ValUnknownRewardBlocks"][relayer])
            val_avg_reward_gauge.labels(relayer).set(avg)
            update_relayer_metric_state("AvgValidatorRewards", relayer, avg, False)
        

def increment_missed_blocks(public_key):
    """
    Increments missed blocks metric

    Parameters:
    -----------
    public_key : str / hex
        The public key of the validator that missed the block
    """
    global missed_gauge

    increment_metric_state("MissedBlockProposals", public_key)
    missed_gauge.labels(public_key).inc() 

def increment_empty_blocks(public_key):
    """
    Increments empty blocks metric

    Parameters:
    -----------
    public_key : str / hex
        The public key of the validator that missed the block
    """
    global empty_gauge

    increment_metric_state("EmptyBlockProposals", public_key)
    empty_gauge.labels(public_key).inc() 

def update_relayer_metric_state(gauge_name, relayer, amount, increment=True):
    """
    Updates relayer metric depending on parameters

    Parameters:
    -----------
    gauge_name : str
        The name of the metric to update
    relayer : str
        The associated relayer to update the metric for
    amount : float
        The amount to update the metric by
    increment : bool
        Whether to increment the metric by the amount (True/default) or to set the metric as the amount (False)
    """
    global data_obj

    if increment:
        data_obj["latest_metrics"][gauge_name][relayer] += amount
    else:
        data_obj["latest_metrics"][gauge_name][relayer] = amount

def update_reward_metrics(relayer, reward):
    """
    Updates relayer reward metrics

    Parameters:
    -----------
    relayer : str
        The name of the relayer to update metrics for
    reward : float
        The reward generated by the relayer
    """
    global total_relay_blocks_gauge, total_rewards_gauge, avg_reward_gauge, unknown_reward_blocks, data_obj
    
    # if the reward is unknown
    if reward == -1:
        # update the number of blocks with unknown rewards
        unknown_reward_blocks.labels(relayer).inc()
        update_relayer_metric_state("UnknownRewardsBlocks", relayer, 1)

        # update the number of blocks relayed by relayer
        total_relay_blocks_gauge.labels(relayer).inc()
        update_relayer_metric_state("TotalRelayBlocksProposed", relayer, 1)
    # if reward value is known
    else:
        # update the number of blocks relayed by relayer
        total_relay_blocks_gauge.labels(relayer).inc()
        update_relayer_metric_state("TotalRelayBlocksProposed", relayer, 1)

        # update the total rewards generated by using this relayer
        total_rewards_gauge.labels(relayer).inc(reward)
        update_relayer_metric_state("RelayTotalRewards", relayer, reward)

        # check if calculation results in 0, so we don't divide by 0
        if (data_obj["latest_metrics"]["TotalRelayBlocksProposed"][relayer] - data_obj["latest_metrics"]["UnknownRewardsBlocks"][relayer]) != 0:
            # update average reward of using specific relayer
            avg = data_obj["latest_metrics"]["RelayTotalRewards"][relayer] / (data_obj["latest_metrics"]["TotalRelayBlocksProposed"][relayer] - data_obj["latest_metrics"]["UnknownRewardsBlocks"][relayer])
            avg_reward_gauge.labels(relayer).set(avg)
            update_relayer_metric_state("AvgRelayerRewards", relayer, avg, False)

def get_epoch_from_slot(slot):
    """
    Calculates the epoch number from the slot number

    Parameters:
    -----------
    slot : int
        The slot number

    Returns:
    --------
    int
        The epoch that the slot is in
    """
    # there are 32 slots in each epoch
    return slot/32

def get_slot_proposer(slot):
    """
    Gets the public key of the block proposer for the given slot

    Parameters:
    -----------
    slot : int
        The slot number

    Returns:
    --------
    str / hex
        The public key of the block proposer (validator) for the slot given
    """
    global config, retries

    epoch = int(get_epoch_from_slot(slot))

    s = requests.Session()
    s.mount('http://', HTTPAdapter(max_retries=retries))

    # get duties for epoch (block proposers)
    duties = s.get(config["eth2_rpc"]+"/eth/v1/validator/duties/proposer/"+str(epoch), timeout=10).json()
    for duty in duties["data"]:
        if duty["slot"] == str(slot):
            # return the public key of the validator for that slot
            return duty["pubkey"]

def check_duties(slot):
    """
    Checks if we can start gathering data from the slot passed by attempting to check duties for the slot's epoch.

    Parameters:
    -----------
    slot : int
        The slot number

    Returns:
    --------
    int
        0: check succeeds and we can gather data from the slot passed onwards
        -1: check failed and slot is too behind to get data
        any other slot number: check failed, and the slot number returned is the largest possible to start from
    """
    global config

    epoch = int(get_epoch_from_slot(slot))

    s = requests.Session()
    temp_retries = Retry(total=10, backoff_factor=0.00005, status_forcelist=[503, 504], allowed_methods=frozenset(['GET', 'POST']))
    s.mount('http://', HTTPAdapter(max_retries=temp_retries))

    # try to get duties for given epoch
    duties = s.get(config["eth2_rpc"]+"/eth/v1/validator/duties/proposer/"+str(epoch), timeout=45).json()

    if 'data' in duties:
        #Â if we have data, then we can proceed
        return 0
    elif 'code' in duties:
        # if there is a status code, then the request failed
        if duties['code'] == 500:
            # try to get the range to let the user know what slot they can start from
            if 'message' in duties:
                range = re.findall(r'\b\d+\b', duties['message'])
                range_ints = [int(x) for x in range]
                return max(range_ints)
    
    # if we failed and cannot get range for user, return -1
    return -1


def check_if_empty(slot):
    """
    Checks if a given slot/block has no transactions i.e. is empty

    Parameters:
    -----------
    slot : int
        The slot number

    Returns:
    --------
    bool
        Whether the block is empty (True) or not (False)
    """
    global config, retries

    try:
        # get the transactions in the given block
        s = requests.Session()
        s.mount('http://', HTTPAdapter(max_retries=retries))
        block = s.get(config["eth2_rpc"]+"/eth/v2/beacon/blocks/"+str(slot), timeout=10).json()
        txs = block["data"]["message"]["body"]["execution_payload"]["transactions"]

        # if there are none, then it is empty
        return len(txs) == 0
    except:
        print("Request failed: "+ config["eth2_rpc"]+"/eth/v2/beacon/blocks/"+str(slot))
        return False 

def update_metrics(data, reward=None):
    """
    Updates metrics related to blocks proposed

    Parameters:
    -----------
    data : object
        Object containing information about the slot, most importantly the public key of the proposer, and the relay used
    """
    global keys, reward_metrics

    # check if proposer is in our list of keys
    if data["proposer"] in keys:
        if data["missed"]:
            # if we missed the block, update the metric
            increment_missed_blocks(data["proposer"])
        elif data["empty"]:
            # if the block is empty, update the metric
            increment_empty_blocks(data["proposer"])
        else:
            # otherwise update the other metrics
            increment_blocks_proposed(data["proposer"], data["relay"])
            
            if reward_metrics:
                update_validator_reward_metrics(data["relay"], reward)

def init_metrics_to_zero(gauge, gauge_dict):
    """
    Initialises the metric passed to 0 for all public keys, except for those in the dictionary. Certain metrics are being monitored
    through increase() in the Grafana dashboard, which means they must have an initial value of 0 in order to be detected

    Parameters:
    -----------
    gauge : Gauge object
        The gauge object of the metric to initialise
    gauge_dict : dict
        Dict containing the values which are not 0. The key is the public key of the validator, and the value is the value of that metric
    """
    global keys

    # first set the metrics for which we have an actual value
    for key, value in gauge_dict.items():
        gauge.labels(key).set(value)
    
    # then initialise the metrics for those that we do not have a value
    for key in keys:
        if key not in gauge_dict:
            gauge.labels(key).set(0)


def load_metrics(metrics_state):
    """
    Updates the prometheus metrics to match the ones passed

    Parameters:
    -----------
    metrics_state : object
        Object containing the different metrics as a dictionary
    """
    global relay_blocks_gauge, total_relay_blocks_gauge, total_rewards_gauge, avg_reward_gauge, unknown_reward_blocks, validator_totals_gauge, missed_gauge, empty_gauge, reward_metrics, val_total_rewards_gauge, val_avg_reward_gauge, val_unknown_reward_blocks

    for key in metrics_state["RelayBlocksProposed"]:
        relay_blocks_gauge.labels(key).set(metrics_state["RelayBlocksProposed"][key]) 

    for key in metrics_state["TotalRelayBlocksProposed"]:
        total_relay_blocks_gauge.labels(key).set(metrics_state["TotalRelayBlocksProposed"][key])

    init_metrics_to_zero(validator_totals_gauge, metrics_state["ValidatorBlocksProposed"])
    init_metrics_to_zero(missed_gauge, metrics_state["MissedBlockProposals"])
    init_metrics_to_zero(empty_gauge, metrics_state["EmptyBlockProposals"])

    if reward_metrics:
        for key in metrics_state["RelayTotalRewards"]:
            total_rewards_gauge.labels(key).set(metrics_state["RelayTotalRewards"][key])

        for key in metrics_state["AvgRelayerRewards"]:
            avg_reward_gauge.labels(key).set(metrics_state["AvgRelayerRewards"][key])

        for key in metrics_state["UnknownRewardsBlocks"]:
            unknown_reward_blocks.labels(key).set(metrics_state["UnknownRewardsBlocks"][key])

        for key in metrics_state["TotalValidatorRewards"]:
            val_total_rewards_gauge.labels(key).set(metrics_state["TotalValidatorRewards"][key])

        for key in metrics_state["AvgValidatorRewards"]:
            val_avg_reward_gauge.labels(key).set(metrics_state["AvgValidatorRewards"][key])

        for key in metrics_state["ValUnknownRewardBlocks"]:
            val_unknown_reward_blocks.labels(key).set(metrics_state["ValUnknownRewardBlocks"][key])

def get_all_relays():
    """
    Gets a list of the relays in the config

    Returns:
    -----------
    list
        A list of the names of the relays
    """
    global relay_config

    relay_list = list(relay_config.keys())

    return relay_list

def init_metrics(last_slot):
    """
    Initialises the metrics to 0

    Parameters:
    -----------
    last_slot : int
        The number of the last slot
    """
    global keys, missed_gauge, empty_gauge, validator_totals_gauge, relay_blocks_gauge, total_relay_blocks_gauge, total_rewards_gauge, avg_reward_gauge, unknown_reward_blocks, data_obj, data, reward_metrics, val_total_rewards_gauge, val_avg_reward_gauge, val_unknown_reward_blocks

    # if it is the first time running script
    if last_slot == 0:
        relay_list = get_all_relays()
        for key in keys:
            # for each key, initialise missed/empty blocks metrics, and blocks proposed metric
            missed_gauge.labels(key).set(0) 
            empty_gauge.labels(key).set(0) 
            validator_totals_gauge.labels(key).set(0) 
            init_metric_state("ValidatorBlocksProposed", key)
            init_metric_state("EmptyBlockProposals", key)
            init_metric_state("MissedBlockProposals", key)

        for relay in relay_list:
            # for each relay, initialise the blocks proposed, total rewards, avg rewards, and blocks with unknown rewards metrics 
            relay_blocks_gauge.labels(relay).set(0) 
            init_metric_state("RelayBlocksProposed", relay)
            total_relay_blocks_gauge.labels(relay).set(0)
            init_metric_state("TotalRelayBlocksProposed", relay)
            if reward_metrics:
                total_rewards_gauge.labels(relay).set(0)
                init_metric_state("RelayTotalRewards", relay)
                avg_reward_gauge.labels(relay).set(0)
                init_metric_state("AvgRelayerRewards", relay)
                unknown_reward_blocks.labels(relay).set(0)
                init_metric_state("UnknownRewardsBlocks", relay)

                # also initialise a separate total, average and unknown reward for the validators we are monitoring
                val_total_rewards_gauge.labels(relay).set(0)
                init_metric_state("TotalValidatorRewards", relay)
                val_avg_reward_gauge.labels(relay).set(0)
                init_metric_state("AvgValidatorRewards", relay)
                val_unknown_reward_blocks.labels(relay).set(0)
                init_metric_state("ValUnknownRewardBlocks", relay)
            
        # also create the metrics above for cases where we don't know who the relayer was or there was no relayer
        relay_blocks_gauge.labels("Unknown").set(0)
        init_metric_state("RelayBlocksProposed", "Unknown")
        total_relay_blocks_gauge.labels("Unknown").set(0)
        init_metric_state("TotalRelayBlocksProposed", "Unknown")
        if reward_metrics:
            total_rewards_gauge.labels("Unknown").set(0)
            init_metric_state("RelayTotalRewards", "Unknown")
            avg_reward_gauge.labels("Unknown").set(0)
            init_metric_state("AvgRelayerRewards", "Unknown")
            unknown_reward_blocks.labels("Unknown").set(0)
            init_metric_state("UnknownRewardsBlocks", "Unknown")
            val_total_rewards_gauge.labels("Unknown").set(0)
            init_metric_state("TotalValidatorRewards", "Unknown")
            val_avg_reward_gauge.labels("Unknown").set(0)
            init_metric_state("AvgValidatorRewards", "Unknown")
            val_unknown_reward_blocks.labels("Unknown").set(0)
            init_metric_state("ValUnknownRewardBlocks", "Unknown")
    else:
        # if it is not our first time, set the data_obj as data
        data_obj = data


def reward_extraction(slot=None, block=None) -> float:
    """
    Calculates rewards for a given slot

    Parameters:
    -----------
    slot : int
        The slot number to get the rewards for
    block : object
        The block json object obtained by requesting /eth/v2/beacon/blocks/{slot_number}

    Returns:
    -----------
    float
        The reward value in ETH
    """
    global config, retries, parallel_requests

    if slot is None and block is None:
        print('At least one argument must be passed.')
    
    # if block was not passed, get it using the rpc
    if slot is not None and block is None:
        s = requests.Session()
        s.mount('http://', HTTPAdapter(max_retries=retries))
        block = s.get(config["eth2_rpc"]+"/eth/v2/beacon/blocks/"+str(slot), timeout=10).json()

    fee_recipient = block['data']['message']['body']['execution_payload']['fee_recipient']
    transactions = block['data']['message']['body']['execution_payload']['transactions']

    # try to find the reward transaction, by checking the last transaction first
    tx_decoded = tx_hash_to_dict(transactions[-1])
    value = match_transaction(fee_recipient, tx_decoded)
    if value != -1:
        return value
    else:
        # if it wasn't the last transaction, try all the other transactions
        for tx in transactions[:-1]:
            value = match_transaction(fee_recipient, tx_hash_to_dict(tx))
            if value != -1:
                return value
    
    # transaction was not found, try other methods
    print("Reward transaction error at slot "+block['data']['message']['slot']+" - reward transaction not found.")

    # if we could not get the transaction, then calculate manually
    if parallel_requests:
        value = calculate_rewards_parallel(int(block['data']['message']['body']['execution_payload']['block_number']), config["eth1_rpc"])
    else:
        value = calculate_rewards(int(block['data']['message']['body']['execution_payload']['block_number']), config["eth1_rpc"])

    return value

def get_non_relayed_slot(slot):
    """
    Queries a beacon chain RPC manually for a slot that was not relayed through one of the relays we're monitoring
    Also calls rewards functions to get reward of slot

    Parameters:
    -----------
    slot : int
        The slot number of the non-relayed slot

    Returns:
    -----------
    object
        The non-relayed slot
    float
        The reward value of the slot in ETH
    """
    global config, relay_config, retries, reward_metrics

    # get the block using a beacon-chain RPC
    s = requests.Session()
    s.mount('http://', HTTPAdapter(max_retries=retries))
    block = s.get(config["eth2_rpc"]+"/eth/v2/beacon/blocks/"+str(slot), timeout=10).json()

    # by default, the relay value is unknown
    relay_value = "Unknown"
    
    # try to read the extra data to find out who the relayer is
    try:
        extra_data = block['data']['message']['body']['execution_payload']['extra_data']

        # if extra_data is 0x, it means it's empty
        if(extra_data != '0x'):
            # if not empty, decode
            extra_data_str = bytes.fromhex(extra_data[2:]).decode('utf-8', 'ignore')
            print(extra_data_str)

            # common relayer extra_data
            if 'bloxroute' in extra_data_str.lower():
                relay_value = 'BloXroute Max Profit'
                print("Matched "+extra_data_str+" with relay BloXroute Max Profit")
            elif 'illuminate dmocratize dstribute' in extra_data_str.lower() or 'illuminate democratize distribute' in extra_data_str.lower():
                relay_value = 'Flashbots'
                print("Matched "+extra_data_str+" with relay Flashbots")
            else:
                # go through each relayer name
                for relay, url in relay_config.items():
                    # check if the name of the relayer or the url of the relayer are in the extra data string
                    if relay.lower() in extra_data_str.lower() or url.lower() in extra_data_str.lower():
                        # if they are, assign that relayer value
                        relay_value = relay
                        print("Matched "+extra_data_str+" with relay "+relay)
                        break
        
        # get the validator public key
        proposer_index = block["data"]["message"]["proposer_index"]
        validator = s.get(config["eth2_rpc"]+"/eth/v1/beacon/states/head/validators/"+str(proposer_index)).json()
        
        # build the slot object
        data = {
            "slot": slot,
            "proposer": validator["data"]["validator"]["pubkey"],
            "relay": relay_value,
            "missed": False,
            "empty": check_if_empty(slot)
        }
    except:
        # otherwise, block is missed / empty
        proposer = get_slot_proposer(slot)
        data = {
            "slot": slot,
            "proposer": proposer,
            "relay": relay_value,
            "missed": True,
            "empty": True
        }

    # if slot is empty / missed there are no rewards
    if data["empty"] or data["missed"] or not reward_metrics:
        return data, -1
    
    if reward_metrics:
        # otherwise calculate rewards
        value = reward_extraction(block=block)

    return data, value

def get_payloads(relay):
    """
    Queries the relayer for payloads / slots

    Parameters:
    -----------
    relay : str
        The name of the relayer to query

    Returns:
    -----------
    list
        List of slots with the following structure:
        "slot": <num>,
        "parent_hash": <hash>,
        "block_hash": <hash>,
        "builder_pubkey": <hex_pub_key>,
        "proposer_pubkey": <hex_pub_key>,
        "proposer_fee_recipient": <hex_address>,
        "gas_limit": <num>,
        "gas_used": <num>,
        "value": <num>
        "relay": <str>
    """
    global relay_config, slots_limit, retries

    print("Requesting Relay: "+relay)

    # initialise list of slots
    slots = []
    success = True

    # try to request relayer
    try:
        s = requests.Session()
        s.mount('http://', HTTPAdapter(max_retries=retries))
        slots = s.get(relay_config[relay]+"/relay/v1/data/bidtraces/proposer_payload_delivered?limit="+str(slots_limit), timeout=10)
        slots.raise_for_status()
    except requests.exceptions.RequestException as e:
        print("Request failed")
        success = False
    
    if(success):
        # if request was successful
        slots = slots.json()
        print("Request completed.")

        # convert strings to ints
        for slot in slots:
            for key in slot:
                if (key in ['slot', 'gas_limit', 'gas_used', 'value']):
                    slot[key] = int(slot[key])
        
        # adding "relay" key
        for slot in slots:
            slot['relay'] = relay
    else:
        # if request failed, return empty list
        slots = []
    
    return slots

def get_all_payloads():
    """
    Calls get_payloads() function for all the relays, to get a complete list of slots

    Returns:
    -----------
    list
        List of slots with the same structure as in get_payloads()
    """

    global relay_config, slots_limit

    # initialise list of payloads
    payloads = []

    # get payloads of each relay
    for relay, _ in relay_config.items():
        res = get_payloads(relay)

        # concatenate payloads into one list
        for payload in res:
            payloads.append(payload)

    # sort by slot number
    payloads = sorted(payloads, key=lambda d: d['slot'])

    # keep only last x slots
    payloads = payloads[-slots_limit:]

    return payloads
            
# initialise data object to hold slots and metrics
data_obj = {
    "last_slot": 0,
    "slots": [],
    "latest_metrics": {
        "RelayBlocksProposed": {},
        "TotalRelayBlocksProposed": {},
        "RelayTotalRewards": {},
        "AvgRelayerRewards": {},
        "UnknownRewardsBlocks": {},
        "ValidatorBlocksProposed": {},
        "MissedBlockProposals": {},
        "EmptyBlockProposals": {},
        "TotalValidatorRewards": {},
        "AvgValidatorRewards": {},
        "ValUnknownRewardBlocks": {}
    }
}

# variable to get last x slots from relayers
slots_limit = 100

# open config
f = open(dirname(__file__)+'/../config/config.json')
config = json.load(f)

# are we tracking rewards?
reward_metrics = config["reward_metrics"]

# should requests to the ETH1 RPC be parallel?
parallel_requests = config["parallel_requests"]

# check if we have a db
if isfile(dirname(__file__)+'/../data/slot_data.db'):
    data = populate_data_obj()
else:
    data = initialise_db()

# check whether we are to continue from the last slot in the database or not
if not config['continue_from_last_slot']:
    data['last_slot'] = config['last_slot'] - 1

# check if database is too old to continue from that point
if data['last_slot'] != 0:
    result = check_duties(data['last_slot'])
    if result == 0:
        pass
    else:
        if result != -1:
            raise Exception("Last slot in database is too old to proceed from. You can start from slot "+str(result+32)+" or higher.")
        else:
            raise Exception("Last slot in database is too old to proceed from.")

# open config of relay names and endpoints
f = open(dirname(__file__)+'/../config/relay_config.json')
relay_config = json.load(f)

# load metrics
latest_metrics = data["latest_metrics"]
last_slot = data["last_slot"]

# load the public keys
with open(dirname(__file__)+'/../config/'+config["keys_file"], 'r') as fp:
    txt = fp.read()
    keys = txt.split(",")

    # remove unnecessary duplicates
    unique = []
    for key in keys:
        if key not in unique:
            unique.append(key)
    keys = unique
    print('Total keys:', len(keys))

# for retrying requests
retries = Retry(total=10, backoff_factor=0.005, status_forcelist=[500, 503, 504], allowed_methods=frozenset(['GET', 'POST']))

if __name__ == '__main__':
    # initialise http server & collector
    start_http_server(config["port"])
    collector = CollectorRegistry()

    # initialise the different metrics
    relay_blocks_gauge = Gauge("RelayBlocksProposed", 'Blocks Proposed by each relay', ["relay"], registry=collector)
    validator_totals_gauge = Gauge("ValidatorBlocksProposed", 'Blocks Proposed by each validator', ["public_key"], registry=collector)
    missed_gauge = Gauge("MissedBlockProposals", 'Missed Blocks Proposals by each validator', ["public_key"], registry=collector)
    empty_gauge = Gauge("EmptyBlockProposals", 'Empty Blocks Proposals by each validator', ["public_key"], registry=collector)
    total_relay_blocks_gauge = Gauge("TotalRelayBlocksProposed", 'Total number of blocks relayed by each relay', ["relay"], registry=collector)

    # reward metrics
    if reward_metrics:
        total_rewards_gauge = Gauge("RelayTotalRewards", 'Total Rewards by each relayer', ["relay"], registry=collector)
        avg_reward_gauge = Gauge("AvgRelayerRewards", 'Average Reward per block by each relayer', ["relay"], registry=collector)
        unknown_reward_blocks = Gauge("UnknownRewardBlocks", 'Total Number of blocks with an unknown reward value', ["relay"], registry=collector)

        val_total_rewards_gauge = Gauge("TotalValidatorRewards", 'Total Rewards by each relayer generated by the validators we are monitoring', ["relay"], registry=collector)
        val_avg_reward_gauge = Gauge("AvgValidatorRewards", 'Average Reward per block by each realyer by the validators we are monitoring', ["relay"], registry=collector)
        val_unknown_reward_blocks = Gauge("ValUnknownRewardBlocks", 'Total Number of blocks with an unknown reward proposed by the validators we are monitoring', ["relay"], registry=collector)

    REGISTRY.register(collector)

    # initialise metric values
    init_metrics(last_slot)
    load_metrics(latest_metrics)

while True: 
    # get all the slots from all the relays
    slots = get_all_payloads()

    for slot in slots:
        if slot["slot"] > data_obj["last_slot"]:
            # if we skipped slots - get data manually through rpc
            if data_obj["last_slot"] != 0 and slot["slot"] != data_obj["last_slot"] + 1:
                # get the missing slots
                missing_slot_count = slot["slot"] - data_obj["last_slot"]
                for i in range(missing_slot_count - 1):
                    missing_slot = data_obj["last_slot"]+i+1
                    print("Missing slot", missing_slot)

                    # get slot and reward value, and update metrics
                    data, reward = get_non_relayed_slot(missing_slot)
                    if reward_metrics:
                        print('Slot: '+str(missing_slot)+'\tReward: '+str(reward))
                    else:
                        print('Slot: '+str(missing_slot))
                    update_metrics(data, reward)
                    insert_new_slot(data['slot'], data['proposer'], data['relay'], data['missed'], data['empty'], reward)

                    if reward_metrics:
                        # update reward metrics and append slot to data_obj
                        update_reward_metrics(data["relay"], reward)
                    data_obj["slots"].append(data)

            # if slot is in relayer data, fill in data
            data = {
                "slot": slot["slot"],
                "proposer": slot["proposer_pubkey"] if "proposer_pubkey" in slot else slot["proposer"],
                "relay": slot["relay"],
                "missed": False,
                "empty": check_if_empty(slot["slot"])
            }

            # reward value is in slot data, divide to get ETH value
            reward = slot["value"] / 1000000000000000000
            print('Slot: '+str(slot["slot"])+'\tReward: '+str(reward))
            data_obj["slots"].append(data)
            data_obj["last_slot"] = slot["slot"]

            insert_new_slot(data['slot'], data['proposer'], data['relay'], data['missed'], data['empty'], reward)

            # update metrics and reward metrics
            update_metrics(data, reward)
            
            if reward_metrics:
                update_reward_metrics(data["relay"], reward)

    # if pruning is enabled, then prune
    if config['pruning']:
        prune_db(config['keep_last_slots'])

    # sleep for 20s
    time.sleep(20)